(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{104:function(e,a,t){"use strict";t.d(a,"a",(function(){return d})),t.d(a,"b",(function(){return u}));var n=t(0),i=t.n(n);function o(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){o(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,n,i=function(e,a){if(null==e)return{};var t,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=i.a.createContext({}),p=function(e){var a=i.a.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},d=function(e){var a=p(e.components);return i.a.createElement(c.Provider,{value:a},e.children)},b={inlineCode:"code",wrapper:function(e){var a=e.children;return i.a.createElement(i.a.Fragment,{},a)}},m=i.a.forwardRef((function(e,a){var t=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(t),m=n,u=d["".concat(l,".").concat(m)]||d[m]||b[m]||o;return t?i.a.createElement(u,r(r({ref:a},c),{},{components:t})):i.a.createElement(u,r({ref:a},c))}));function u(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var o=t.length,l=new Array(o);l[0]=m;var r={};for(var s in a)hasOwnProperty.call(a,s)&&(r[s]=a[s]);r.originalType=e,r.mdxType="string"==typeof e?e:n,l[1]=r;for(var c=2;c<o;c++)l[c]=t[c];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},58:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return l})),t.d(a,"metadata",(function(){return r})),t.d(a,"rightToc",(function(){return s})),t.d(a,"default",(function(){return p}));var n=t(2),i=t(6),o=(t(0),t(104)),l={title:"Validating Protobufs",sidebar_label:"Validation",layout:"docs"},r={unversionedId:"validation",id:"validation",isDocsHomePage:!1,title:"Validating Protobufs",description:"scalapb-validate is a code generator that generates validation methods for your messages based on rules and constraints defined in the proto. It uses the same validation rules provided by protoc-gen-validate.",source:"@site/../docs/target/mdoc/validation.md",slug:"/validation",permalink:"/docs/validation",version:"current",sidebar_label:"Validation",sidebar:"someSidebar",previous:{title:"Common protos",permalink:"/docs/common-protos"},next:{title:"Writing generic code",permalink:"/docs/generic"}},s=[{value:"Introduction",id:"introduction",children:[]},{value:"Installation",id:"installation",children:[]},{value:"Using the generated code",id:"using-the-generated-code",children:[]},{value:"Validators",id:"validators",children:[]},{value:"Rule-based type customization",id:"rule-based-type-customization",children:[{value:"Installation",id:"installation-1",children:[]},{value:"Field transformations",id:"field-transformations",children:[]}]},{value:"Cats non-empty collections",id:"cats-non-empty-collections",children:[]},{value:"Package-scoped extension options",id:"package-scoped-extension-options",children:[]}],c={rightToc:s};function p(e){var a=e.components,t=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},c,t,{components:a,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"scalapb-validate")," is a code generator that generates validation methods for your messages based on rules and constraints defined in the proto. It uses the same validation rules provided by ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/envoyproxy/protoc-gen-validate"}),"protoc-gen-validate"),"."),Object(o.b)("h2",{id:"introduction"},"Introduction"),Object(o.b)("p",null,"In many situations, you may want to add validation rules for your messages. For example, you might want to enforce that a certain string field is an email address, or that a repeated field has at least one element."),Object(o.b)("p",null,"Such rules and constraints can be defined using custom options defined in ",Object(o.b)("inlineCode",{parentName:"p"},"validate/validate.proto"),". Here is an example taken from ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/envoyproxy/protoc-gen-validate/blob/master/README.md"}),"protoc-gen-validate's documentation"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-protobuf"}),'syntax = "proto3";\n\npackage examplepb;\n\nimport "validate/validate.proto";\n\nmessage Person {\n  uint64 id    = 1 [(validate.rules).uint64.gt    = 999];\n\n  string email = 2 [(validate.rules).string.email = true];\n\n  string name  = 3 [(validate.rules).string = {\n                      pattern:   "^[^[0-9]A-Za-z]+( [^[0-9]A-Za-z]+)*$",\n                      max_bytes: 256,\n                   }];\n\n  Location home = 4 [(validate.rules).message.required = true];\n\n  message Location {\n    double lat = 1 [(validate.rules).double = { gte: -90,  lte: 90 }];\n    double lng = 2 [(validate.rules).double = { gte: -180, lte: 180 }];\n  }\n}\n')),Object(o.b)("p",null,"scalapb-validate supports all the rules available in protoc-gen-validate and is tested with the same test harness containing over 900 test cases."),Object(o.b)("h2",{id:"installation"},"Installation"),Object(o.b)("p",null,"Add the following to your ",Object(o.b)("inlineCode",{parentName:"p"},"project/plugins.sbt"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'addSbtPlugin("com.thesamet" % "sbt-protoc" % "1.0.0-RC4")\n\nlibraryDependencies ++= Seq(\n    "com.thesamet.scalapb" %% "compilerplugin"           % "0.10.9",\n    "com.thesamet.scalapb" %% "scalapb-validate-codegen" % "0.1.3"\n)\n')),Object(o.b)("p",null,"Change your ",Object(o.b)("inlineCode",{parentName:"p"},"PB.targets")," to generate the validation code. The output directory must be the same as the one used for ",Object(o.b)("inlineCode",{parentName:"p"},"scalapb.gen"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'PB.targets in Compile := Seq(\n  scalapb.gen() -> (sourceManaged in Compile).value / "scalapb",\n  scalapb.validate.gen() -> (sourceManaged in Compile).value / "scalapb"\n)\n\nlibraryDependencies ++= Seq(\n  "com.thesamet.scalapb" %% "scalapb-validate-core" % scalapb.validate.compiler.BuildInfo.version % "protobuf"\n)\n')),Object(o.b)("p",null,"Note that we are adding ",Object(o.b)("inlineCode",{parentName:"p"},"scalapb-validate-core")," as a ",Object(o.b)("inlineCode",{parentName:"p"},"protobuf")," dependency. This makes it possible to import ",Object(o.b)("inlineCode",{parentName:"p"},"validate/validate.proto")," from your own protos."),Object(o.b)("h2",{id:"using-the-generated-code"},"Using the generated code"),Object(o.b)("p",null,"Generated code for both ScalaPB and scalapb-validate is generated at compilation time. In ",Object(o.b)("inlineCode",{parentName:"p"},"sbt"),", just type ",Object(o.b)("inlineCode",{parentName:"p"},"compile"),"."),Object(o.b)("p",null,"In addition to the standard ScalaPB generated files, scalapb-validate will generate a validator object for each message based on its protoc-gen-validate rules. For a message named ",Object(o.b)("inlineCode",{parentName:"p"},"Msg")," the validator object will be named ",Object(o.b)("inlineCode",{parentName:"p"},"MsgValidator")," and will extend ",Object(o.b)("inlineCode",{parentName:"p"},"scalapb.validate.Validator[Msg]"),". An implicit instance of the validator is added to the companion object of each message, which makes it possible to write ",Object(o.b)("inlineCode",{parentName:"p"},"Validator[Msg]")," to obtain an instance of the validator."),Object(o.b)("h2",{id:"validators"},"Validators"),Object(o.b)("p",null,"The validator object is an object with a ",Object(o.b)("inlineCode",{parentName:"p"},"validate")," method that takes an instance of a message and returns the validation result: The ",Object(o.b)("inlineCode",{parentName:"p"},"Validator[T]")," is defined as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"trait Validator[T] {\n  def validate(t: T): Result\n}\n")),Object(o.b)("p",null,"where ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," is a data structure that can be either a ",Object(o.b)("inlineCode",{parentName:"p"},"Success")," or a ",Object(o.b)("inlineCode",{parentName:"p"},"Failure"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"sealed trait Result {\n  def isSuccess: Boolean\n  def isFailure: Boolean\n}\n\ncase object Success extends Result { ... }\n\ncase class Failure(violations: List[ValidationException]) extends Result { ... }\n")),Object(o.b)("p",null,"Therefore, the validation for the test person casn be run like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'Validator[Person].validate(personInstance) match {\n  case Success             => println("Success!")\n  case Failure(violations) => println(violations)\n}\n')),Object(o.b)("h2",{id:"rule-based-type-customization"},"Rule-based type customization"),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"The functionality described in the remainder of this page is available in a preview release of ScalaPB. It is still being refined and is subject to change without notice."))),Object(o.b)("p",null,"Starting from version 0.10.10, ScalaPB-validate provides a way to customize the generated ScalaPB types by writing rules. When these rules are matched, additional ScalaPB options are added to the matched entity. For example, you can create a transformation that whenever a field has a PGV-rule like ",Object(o.b)("inlineCode",{parentName:"p"},"int32: { gt: 0 }}"),", then it will be typemapped to a custom class ",Object(o.b)("inlineCode",{parentName:"p"},"PositiveInt"),"."),Object(o.b)("h3",{id:"installation-1"},"Installation"),Object(o.b)("p",null,"The minimum required versions of sbt-protoc is ",Object(o.b)("inlineCode",{parentName:"p"},"1.0.0-RC6"),". You will also need a preview version of\nScalaPB and ScalaPB-validate. Your ",Object(o.b)("inlineCode",{parentName:"p"},"project/plugins.sbt")," should have something like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'addSbtPlugin("com.thesamet" % "sbt-protoc" % "1.0.0-RC6")\n\nlibraryDependencies ++= Seq(\n    "com.thesamet.scalapb" %% "compilerplugin"           % "0.10.10-preview2",\n    "com.thesamet.scalapb" %% "scalapb-validate-codegen" % "0.2.0-preview3"\n)\n')),Object(o.b)("p",null,"The key ingredient for type transformations is to have a ",Object(o.b)("em",{parentName:"p"},"preprocessor")," plugin running before ScalaPB,\nletting it know which types to use. Your build.sbt should set ",Object(o.b)("inlineCode",{parentName:"p"},"PB.targets in Compile")," like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'PB.targets in Compile := Seq(\n  scalapb.validate.preprocessor() -> (sourceManaged in Compile).value / "scalapb",\n  scalapb.gen() -> (sourceManaged in Compile).value / "scalapb",\n  scalapb.validate.gen() -> (sourceManaged in Compile).value / "scalapb"\n)\n\nlibraryDependencies ++= Seq(\n  "com.thesamet.scalapb" %% "scalapb-validate-core" % scalapb.validate.compiler.BuildInfo.version % "protobuf",\n\n  // If you are using Cats transformations:\n  "com.thesamet.scalapb" %% "scalapb-validate-cats" % scalapb.validate.compiler.BuildInfo.version,\n  "org.typelevel" %% "cats-core" % "2.3.0"\n)\n')),Object(o.b)("p",null,"There is an example project ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/scalapb/scalapb-validate-demo"}),"available on github"),"."),Object(o.b)("h3",{id:"field-transformations"},"Field transformations"),Object(o.b)("p",null,"if you want all your positive integers to be typemapped to a Scala class called ",Object(o.b)("inlineCode",{parentName:"p"},"PositiveInt")," you can create a proto file with the following content:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-protobuf"}),'syntax = "proto2";\n\npackage mypackage;\n\nimport "scalapb/scalapb.proto";\nimport "scalapb/validate.proto";\nimport "validate/validate.proto";\n\noption (scalapb.options) = {\n  preprocessors: ["scalapb-validate-preprocessor"]\n};\n\noption (scalapb.validate.package) = {\n  field_transformations: [\n    {\n      when: {int32: {gt: 0}}\n      set: {\n        type: "mypkg.PositiveInt"\n      }\n    }\n  ]\n};\n')),Object(o.b)("p",null,"The scope of this definition is the entire protobuf package it is found in. Here, ",Object(o.b)("inlineCode",{parentName:"p"},"field_transformations")," is a list of ",Object(o.b)("inlineCode",{parentName:"p"},"FieldTransformation")," messages. Each of them describes a single rule. The ",Object(o.b)("inlineCode",{parentName:"p"},"when")," condition is a PGV ",Object(o.b)("inlineCode",{parentName:"p"},"FieldRule")," (defined in ",Object(o.b)("inlineCode",{parentName:"p"},"validate/validate.proto"),"). When it is matched for any field in this package, the ",Object(o.b)("inlineCode",{parentName:"p"},"scalapb.FieldOption")," options in ",Object(o.b)("inlineCode",{parentName:"p"},"set")," are applied to the field.  Multiple transformations may match a single field. The order this happens is subject to change and should not be assumed."),Object(o.b)("p",null,"The default matching mode is called ",Object(o.b)("inlineCode",{parentName:"p"},"CONTAINS"),". In this mode, the actual PGV rules for the field may contain additional additional options besides the one being matched on. Another matching mode is available and is called ",Object(o.b)("inlineCode",{parentName:"p"},"EXACT"),".  In this mode, the ",Object(o.b)("inlineCode",{parentName:"p"},"when")," pattern must match exactly the field's rules. Example syntax:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-protobuf"}),'option (scalapb.validate.package) = {\n  field_transformations: [\n    {\n      when: {int32: {gt: 0}}\n      match_type: EXACT\n      set: {\n        type: "mypkg.PositiveInt"\n      }\n    }\n  ]\n};\n')),Object(o.b)("h2",{id:"cats-non-empty-collections"},"Cats non-empty collections"),Object(o.b)("p",null,"Using rules like the ones defined above, it is possible to detect when a list or a map are non-empty (via. ",Object(o.b)("inlineCode",{parentName:"p"},"{repeated: { min_items: 1}}")," or ",Object(o.b)("inlineCode",{parentName:"p"},"{map: {min_pairs: 1}}"),", and map them to corresponding non-empty collections.  Cats collections require some additional adaptation to ScalaPB since their API is different enough from standard Scala collections. ScalaPB comes with support to automatically map non-empty collections to ",Object(o.b)("inlineCode",{parentName:"p"},"NonEmptyMap"),", ",Object(o.b)("inlineCode",{parentName:"p"},"NonEmptySet")," and ",Object(o.b)("inlineCode",{parentName:"p"},"NonEmptyList"),". To enable, add the following to a proto file. The scope of the settings will be for the entire proto package:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-protobuf"}),'\nsyntax = "proto2";\n\npackage mypackage;\n\nimport "scalapb/scalapb.proto";\nimport "scalapb/validate.proto";\nimport "validate/validate.proto";\n\noption (scalapb.options) = {\n  preprocessors: ["scalapb-validate-preprocessor"]\n};\n\noption (scalapb.validate.package) = {\n  cats_transforms: true\n  unique_to_set: true\n};\n')),Object(o.b)("p",null,"As stated above, you will need to have ",Object(o.b)("inlineCode",{parentName:"p"},"scalapb-validate-cats")," listed in\n",Object(o.b)("inlineCode",{parentName:"p"},"libraryDependencies"),". The setting ",Object(o.b)("inlineCode",{parentName:"p"},"unique_to_set")," can be used independently\nof cats to transform a repeated with ",Object(o.b)("inlineCode",{parentName:"p"},"unique: true")," rule to a set."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"Validation is performed only after a message is instantiated. Therefore, when you use\na ",Object(o.b)("inlineCode",{parentName:"p"},"Set")," or a ",Object(o.b)("inlineCode",{parentName:"p"},"NonEmptySet")," instead of list, duplicate elements are deduped during parsing time,\nwhen ScalaPB adds them to the collections' builder. As a result, uniqueness\nvalidation will always succeed, even when the original message had duplicate\nelements."))),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"libraryDependencie")," to ensure"),Object(o.b)("h2",{id:"package-scoped-extension-options"},"Package-scoped extension options"),Object(o.b)("p",null,"ScalaPB-validate further extends ScalaPB's package-scoped options to achieve additional customization:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-protobuf"}),'syntax = "proto2";\n\npackage mypkg;\n\nimport "scalapb/scalapb.proto";\nimport "scalapb/validate.proto";\n\noption (scalapb.options) = {\n  scope: PACKAGE\n  [scalapb.validate.file] {\n      validate_at_construction: true\n      insert_validator_instance: true\n  }\n};\n')),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"validate_at_construction")," when true, a check for validity is added to the message class body, so construction of invalid messages results in a validation exception. Default: ",Object(o.b)("inlineCode",{parentName:"li"},"false"),"."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"insert_validator_instance")," when true, implicit instance of a ",Object(o.b)("inlineCode",{parentName:"li"},"Validator")," is added to the companion object of the message. This enables writing ",Object(o.b)("inlineCode",{parentName:"li"},"Validator[MyMsg].validate(instance)"),". Default: ",Object(o.b)("inlineCode",{parentName:"li"},"true"),".")))}p.isMDXComponent=!0}}]);